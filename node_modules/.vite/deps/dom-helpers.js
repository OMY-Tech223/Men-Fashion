import {
  addClass,
  hasClass,
  removeClass
} from "./chunk-PQNFXMK4.js";
import {
  _extends
} from "./chunk-EQCCHGRT.js";
import "./chunk-DC5AMYBS.js";

// node_modules/dom-helpers/esm/ownerDocument.js
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}

// node_modules/dom-helpers/esm/activeElement.js
function activeElement(doc) {
  if (doc === void 0) {
    doc = ownerDocument();
  }
  try {
    var active = doc.activeElement;
    if (!active || !active.nodeName) return null;
    return active;
  } catch (e) {
    return doc.body;
  }
}

// node_modules/dom-helpers/esm/canUseDOM.js
var canUseDOM_default = !!(typeof window !== "undefined" && window.document && window.document.createElement);

// node_modules/dom-helpers/esm/addEventListener.js
var optionsSupported = false;
var onceSupported = false;
try {
  options = {
    get passive() {
      return optionsSupported = true;
    },
    get once() {
      return onceSupported = optionsSupported = true;
    }
  };
  if (canUseDOM_default) {
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, true);
  }
} catch (e) {
}
var options;
function addEventListener(node, eventName, handler, options) {
  if (options && typeof options !== "boolean" && !onceSupported) {
    var once = options.once, capture = options.capture;
    var wrappedHandler = handler;
    if (!onceSupported && once) {
      wrappedHandler = handler.__once || function onceHandler(event) {
        this.removeEventListener(eventName, onceHandler, capture);
        handler.call(this, event);
      };
      handler.__once = wrappedHandler;
    }
    node.addEventListener(eventName, wrappedHandler, optionsSupported ? options : capture);
  }
  node.addEventListener(eventName, handler, options);
}
var addEventListener_default = addEventListener;

// node_modules/dom-helpers/esm/ownerWindow.js
function ownerWindow(node) {
  var doc = ownerDocument(node);
  return doc && doc.defaultView || window;
}

// node_modules/dom-helpers/esm/getComputedStyle.js
function getComputedStyle(node, psuedoElement) {
  return ownerWindow(node).getComputedStyle(node, psuedoElement);
}

// node_modules/dom-helpers/esm/hyphenate.js
var rUpper = /([A-Z])/g;
function hyphenate(string) {
  return string.replace(rUpper, "-$1").toLowerCase();
}

// node_modules/dom-helpers/esm/hyphenateStyle.js
var msPattern = /^ms-/;
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, "-ms-");
}

// node_modules/dom-helpers/esm/isTransform.js
var supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;
function isTransform(value) {
  return !!(value && supportedTransforms.test(value));
}

// node_modules/dom-helpers/esm/css.js
function style(node, property) {
  var css = "";
  var transforms = "";
  if (typeof property === "string") {
    return node.style.getPropertyValue(hyphenateStyleName(property)) || getComputedStyle(node).getPropertyValue(hyphenateStyleName(property));
  }
  Object.keys(property).forEach(function(key) {
    var value = property[key];
    if (!value && value !== 0) {
      node.style.removeProperty(hyphenateStyleName(key));
    } else if (isTransform(key)) {
      transforms += key + "(" + value + ") ";
    } else {
      css += hyphenateStyleName(key) + ": " + value + ";";
    }
  });
  if (transforms) {
    css += "transform: " + transforms + ";";
  }
  node.style.cssText += ";" + css;
}
var css_default = style;

// node_modules/dom-helpers/esm/removeEventListener.js
function removeEventListener(node, eventName, handler, options) {
  var capture = options && typeof options !== "boolean" ? options.capture : options;
  node.removeEventListener(eventName, handler, capture);
  if (handler.__once) {
    node.removeEventListener(eventName, handler.__once, capture);
  }
}
var removeEventListener_default = removeEventListener;

// node_modules/dom-helpers/esm/listen.js
function listen(node, eventName, handler, options) {
  addEventListener_default(node, eventName, handler, options);
  return function() {
    removeEventListener_default(node, eventName, handler, options);
  };
}
var listen_default = listen;

// node_modules/dom-helpers/esm/triggerEvent.js
function triggerEvent(node, eventName, bubbles, cancelable) {
  if (bubbles === void 0) {
    bubbles = false;
  }
  if (cancelable === void 0) {
    cancelable = true;
  }
  if (node) {
    var event = document.createEvent("HTMLEvents");
    event.initEvent(eventName, bubbles, cancelable);
    node.dispatchEvent(event);
  }
}

// node_modules/dom-helpers/esm/transitionEnd.js
function parseDuration(node) {
  var str = css_default(node, "transitionDuration") || "";
  var mult = str.indexOf("ms") === -1 ? 1e3 : 1;
  return parseFloat(str) * mult;
}
function emulateTransitionEnd(element, duration, padding) {
  if (padding === void 0) {
    padding = 5;
  }
  var called = false;
  var handle = setTimeout(function() {
    if (!called) triggerEvent(element, "transitionend", true);
  }, duration + padding);
  var remove2 = listen_default(element, "transitionend", function() {
    called = true;
  }, {
    once: true
  });
  return function() {
    clearTimeout(handle);
    remove2();
  };
}
function transitionEnd(element, handler, duration, padding) {
  if (duration == null) duration = parseDuration(element) || 0;
  var removeEmulate = emulateTransitionEnd(element, duration, padding);
  var remove2 = listen_default(element, "transitionend", handler);
  return function() {
    removeEmulate();
    remove2();
  };
}

// node_modules/dom-helpers/esm/animate.js
var reset = {
  transition: "",
  "transition-duration": "",
  "transition-delay": "",
  "transition-timing-function": ""
};
function _animate(_ref) {
  var node = _ref.node, properties = _ref.properties, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 200 : _ref$duration, easing = _ref.easing, callback = _ref.callback;
  var cssProperties = [];
  var cssValues = {};
  var transforms = "";
  Object.keys(properties).forEach(function(key) {
    var value = properties[key];
    if (isTransform(key)) transforms += key + "(" + value + ") ";
    else {
      cssValues[key] = value;
      cssProperties.push(hyphenate(key));
    }
  });
  if (transforms) {
    cssValues.transform = transforms;
    cssProperties.push("transform");
  }
  function done(event) {
    if (event.target !== event.currentTarget) return;
    css_default(node, reset);
    if (callback) callback.call(this, event);
  }
  if (duration > 0) {
    cssValues.transition = cssProperties.join(", ");
    cssValues["transition-duration"] = duration / 1e3 + "s";
    cssValues["transition-delay"] = "0s";
    cssValues["transition-timing-function"] = easing || "linear";
  }
  var removeListener = transitionEnd(node, done, duration);
  node.clientLeft;
  css_default(node, cssValues);
  return {
    cancel: function cancel3() {
      removeListener();
      css_default(node, reset);
    }
  };
}
function animate(nodeOrOptions, properties, duration, easing, callback) {
  if (!("nodeType" in nodeOrOptions)) {
    return _animate(nodeOrOptions);
  }
  if (!properties) {
    throw new Error("must include properties to animate");
  }
  if (typeof easing === "function") {
    callback = easing;
    easing = "";
  }
  return _animate({
    node: nodeOrOptions,
    properties,
    duration,
    easing,
    callback
  });
}
var animate_default = animate;

// node_modules/dom-helpers/esm/animationFrame.js
var prev = (/* @__PURE__ */ new Date()).getTime();
function fallback(fn) {
  var curr = (/* @__PURE__ */ new Date()).getTime();
  var ms = Math.max(0, 16 - (curr - prev));
  var handle = setTimeout(fn, ms);
  prev = curr;
  return handle;
}
var vendors = ["", "webkit", "moz", "o", "ms"];
var cancelMethod = "clearTimeout";
var rafImpl = fallback;
var getKey = function getKey2(vendor, k) {
  return vendor + (!vendor ? k : k[0].toUpperCase() + k.substr(1)) + "AnimationFrame";
};
if (canUseDOM_default) {
  vendors.some(function(vendor) {
    var rafMethod = getKey(vendor, "request");
    if (rafMethod in window) {
      cancelMethod = getKey(vendor, "cancel");
      rafImpl = function rafImpl2(cb) {
        return window[rafMethod](cb);
      };
    }
    return !!rafImpl;
  });
}
var cancel = function cancel2(id) {
  if (typeof window[cancelMethod] === "function") window[cancelMethod](id);
};
var request = rafImpl;

// node_modules/dom-helpers/esm/attribute.js
function attribute(node, attr, val) {
  if (node) {
    if (typeof val === "undefined") {
      return node.getAttribute(attr);
    }
    if (!val && val !== "") {
      node.removeAttribute(attr);
    } else {
      node.setAttribute(attr, String(val));
    }
  }
}

// node_modules/dom-helpers/esm/childElements.js
function childElements(node) {
  return node ? Array.from(node.children) : [];
}

// node_modules/dom-helpers/esm/clear.js
function clear(node) {
  if (node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    return node;
  }
  return null;
}

// node_modules/dom-helpers/esm/matches.js
var matchesImpl;
function matches(node, selector) {
  if (!matchesImpl) {
    var body = document.body;
    var nativeMatch = body.matches || body.matchesSelector || body.webkitMatchesSelector || body.mozMatchesSelector || body.msMatchesSelector;
    matchesImpl = function matchesImpl2(n, s) {
      return nativeMatch.call(n, s);
    };
  }
  return matchesImpl(node, selector);
}

// node_modules/dom-helpers/esm/closest.js
function closest(node, selector, stopAt) {
  if (node.closest && !stopAt) node.closest(selector);
  var nextNode = node;
  do {
    if (matches(nextNode, selector)) return nextNode;
    nextNode = nextNode.parentElement;
  } while (nextNode && nextNode !== stopAt && nextNode.nodeType === document.ELEMENT_NODE);
  return null;
}

// node_modules/dom-helpers/esm/contains.js
function contains(context, node) {
  if (context.contains) return context.contains(node);
  if (context.compareDocumentPosition) return context === node || !!(context.compareDocumentPosition(node) & 16);
}

// node_modules/dom-helpers/esm/childNodes.js
var toArray = Function.prototype.bind.call(Function.prototype.call, [].slice);
function childNodes(node) {
  return node ? toArray(node.childNodes) : [];
}

// node_modules/dom-helpers/esm/querySelectorAll.js
var toArray2 = Function.prototype.bind.call(Function.prototype.call, [].slice);
function qsa(element, selector) {
  return toArray2(element.querySelectorAll(selector));
}

// node_modules/dom-helpers/esm/filterEventHandler.js
function filterEvents(selector, handler) {
  return function filterHandler(e) {
    var top = e.currentTarget;
    var target = e.target;
    var matches2 = qsa(top, selector);
    if (matches2.some(function(match) {
      return contains(match, target);
    })) handler.call(this, e);
  };
}

// node_modules/dom-helpers/esm/isDocument.js
function isDocument(element) {
  return "nodeType" in element && element.nodeType === document.DOCUMENT_NODE;
}

// node_modules/dom-helpers/esm/isWindow.js
function isWindow(node) {
  if ("window" in node && node.window === node) return node;
  if (isDocument(node)) return node.defaultView || false;
  return false;
}

// node_modules/dom-helpers/esm/getScrollAccessor.js
function getscrollAccessor(offset2) {
  var prop = offset2 === "pageXOffset" ? "scrollLeft" : "scrollTop";
  function scrollAccessor(node, val) {
    var win = isWindow(node);
    if (val === void 0) {
      return win ? win[offset2] : node[prop];
    }
    if (win) {
      win.scrollTo(win[offset2], val);
    } else {
      node[prop] = val;
    }
  }
  return scrollAccessor;
}

// node_modules/dom-helpers/esm/scrollLeft.js
var scrollLeft_default = getscrollAccessor("pageXOffset");

// node_modules/dom-helpers/esm/scrollTop.js
var scrollTop_default = getscrollAccessor("pageYOffset");

// node_modules/dom-helpers/esm/offset.js
function offset(node) {
  var doc = ownerDocument(node);
  var box = {
    top: 0,
    left: 0,
    height: 0,
    width: 0
  };
  var docElem = doc && doc.documentElement;
  if (!docElem || !contains(docElem, node)) return box;
  if (node.getBoundingClientRect !== void 0) box = node.getBoundingClientRect();
  box = {
    top: box.top + scrollTop_default(docElem) - (docElem.clientTop || 0),
    left: box.left + scrollLeft_default(docElem) - (docElem.clientLeft || 0),
    width: box.width,
    height: box.height
  };
  return box;
}

// node_modules/dom-helpers/esm/height.js
function height(node, client) {
  var win = isWindow(node);
  return win ? win.innerHeight : client ? node.clientHeight : offset(node).height;
}

// node_modules/dom-helpers/esm/insertAfter.js
function insertAfter(node, refNode) {
  if (node && refNode && refNode.parentNode) {
    if (refNode.nextSibling) {
      refNode.parentNode.insertBefore(node, refNode.nextSibling);
    } else {
      refNode.parentNode.appendChild(node);
    }
    return node;
  }
  return null;
}

// node_modules/dom-helpers/esm/isInput.js
var regExpInputs = /^(?:input|select|textarea|button)$/i;
function isInput(node) {
  return node ? regExpInputs.test(node.nodeName) : false;
}

// node_modules/dom-helpers/esm/isVisible.js
function isVisible(node) {
  return node ? !!(node.offsetWidth || node.offsetHeight || node.getClientRects().length) : false;
}

// node_modules/dom-helpers/esm/collectSiblings.js
function collectSiblings(node, refNode, selector) {
  if (refNode === void 0) {
    refNode = null;
  }
  if (selector === void 0) {
    selector = null;
  }
  var siblings2 = [];
  for (; node; node = node.nextElementSibling) {
    if (node !== refNode) {
      if (selector && matches(node, selector)) {
        break;
      }
      siblings2.push(node);
    }
  }
  return siblings2;
}

// node_modules/dom-helpers/esm/nextUntil.js
function nextUntil(node, selector) {
  return collectSiblings(node, node, selector);
}

// node_modules/dom-helpers/esm/offsetParent.js
var isHTMLElement = function isHTMLElement2(e) {
  return !!e && "offsetParent" in e;
};
function offsetParent(node) {
  var doc = ownerDocument(node);
  var parent = node && node.offsetParent;
  while (isHTMLElement(parent) && parent.nodeName !== "HTML" && css_default(parent, "position") === "static") {
    parent = parent.offsetParent;
  }
  return parent || doc.documentElement;
}

// node_modules/dom-helpers/esm/collectElements.js
function collectElements(node, direction) {
  var nextNode = null;
  var nodes = [];
  nextNode = node ? node[direction] : null;
  while (nextNode && nextNode.nodeType !== 9) {
    nodes.push(nextNode);
    nextNode = nextNode[direction] || null;
  }
  return nodes;
}

// node_modules/dom-helpers/esm/parents.js
function parents(node) {
  return collectElements(node, "parentElement");
}

// node_modules/dom-helpers/esm/position.js
var nodeName = function nodeName2(node) {
  return node.nodeName && node.nodeName.toLowerCase();
};
function position(node, offsetParent2) {
  var parentOffset = {
    top: 0,
    left: 0
  };
  var offset2;
  if (css_default(node, "position") === "fixed") {
    offset2 = node.getBoundingClientRect();
  } else {
    var parent = offsetParent2 || offsetParent(node);
    offset2 = offset(node);
    if (nodeName(parent) !== "html") parentOffset = offset(parent);
    var borderTop = String(css_default(parent, "borderTopWidth") || 0);
    parentOffset.top += parseInt(borderTop, 10) - scrollTop_default(parent) || 0;
    var borderLeft = String(css_default(parent, "borderLeftWidth") || 0);
    parentOffset.left += parseInt(borderLeft, 10) - scrollLeft_default(parent) || 0;
  }
  var marginTop = String(css_default(node, "marginTop") || 0);
  var marginLeft = String(css_default(node, "marginLeft") || 0);
  return _extends({}, offset2, {
    top: offset2.top - parentOffset.top - (parseInt(marginTop, 10) || 0),
    left: offset2.left - parentOffset.left - (parseInt(marginLeft, 10) || 0)
  });
}

// node_modules/dom-helpers/esm/prepend.js
function prepend(node, parent) {
  if (node && parent) {
    if (parent.firstElementChild) {
      parent.insertBefore(node, parent.firstElementChild);
    } else {
      parent.appendChild(node);
    }
    return node;
  }
  return null;
}

// node_modules/dom-helpers/esm/remove.js
function remove(node) {
  if (node && node.parentNode) {
    node.parentNode.removeChild(node);
    return node;
  }
  return null;
}

// node_modules/dom-helpers/esm/scrollbarSize.js
var size;
function scrollbarSize(recalc) {
  if (!size && size !== 0 || recalc) {
    if (canUseDOM_default) {
      var scrollDiv = document.createElement("div");
      scrollDiv.style.position = "absolute";
      scrollDiv.style.top = "-9999px";
      scrollDiv.style.width = "50px";
      scrollDiv.style.height = "50px";
      scrollDiv.style.overflow = "scroll";
      document.body.appendChild(scrollDiv);
      size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
    }
  }
  return size;
}

// node_modules/dom-helpers/esm/scrollParent.js
function scrollParent(element, firstPossible) {
  var position2 = css_default(element, "position");
  var excludeStatic = position2 === "absolute";
  var ownerDoc = element.ownerDocument;
  if (position2 === "fixed") return ownerDoc || document;
  while ((element = element.parentNode) && !isDocument(element)) {
    var isStatic = excludeStatic && css_default(element, "position") === "static";
    var style2 = (css_default(element, "overflow") || "") + (css_default(element, "overflow-y") || "") + css_default(element, "overflow-x");
    if (isStatic) continue;
    if (/(auto|scroll)/.test(style2) && (firstPossible || height(element) < element.scrollHeight)) {
      return element;
    }
  }
  return ownerDoc || document;
}

// node_modules/dom-helpers/esm/scrollTo.js
function scrollTo(selected, scrollParent2) {
  var offset2 = offset(selected);
  var poff = {
    top: 0,
    left: 0
  };
  if (!selected) return void 0;
  var list = scrollParent2 || scrollParent(selected);
  var isWin = isWindow(list);
  var listScrollTop = scrollTop_default(list);
  var listHeight = height(list, true);
  if (!isWin) poff = offset(list);
  offset2 = {
    top: offset2.top - poff.top,
    left: offset2.left - poff.left,
    height: offset2.height,
    width: offset2.width
  };
  var selectedHeight = offset2.height;
  var selectedTop = offset2.top + (isWin ? 0 : listScrollTop);
  var bottom = selectedTop + selectedHeight;
  listScrollTop = listScrollTop > selectedTop ? selectedTop : bottom > listScrollTop + listHeight ? bottom - listHeight : listScrollTop;
  var id = request(function() {
    return scrollTop_default(list, listScrollTop);
  });
  return function() {
    return cancel(id);
  };
}

// node_modules/dom-helpers/esm/siblings.js
function siblings(node) {
  return collectSiblings(node && node.parentElement ? node.parentElement.firstElementChild : null, node);
}

// node_modules/dom-helpers/esm/text.js
var regExpNbspEntity = /&nbsp;/gi;
var regExpNbspHex = /\xA0/g;
var regExpSpaces = /\s+([^\s])/gm;
function text(node, trim, singleSpaces) {
  if (trim === void 0) {
    trim = true;
  }
  if (singleSpaces === void 0) {
    singleSpaces = true;
  }
  var elementText = "";
  if (node) {
    elementText = (node.textContent || "").replace(regExpNbspEntity, " ").replace(regExpNbspHex, " ");
    if (trim) {
      elementText = elementText.trim();
    }
    if (singleSpaces) {
      elementText = elementText.replace(regExpSpaces, " $1");
    }
  }
  return elementText;
}

// node_modules/dom-helpers/esm/toggleClass.js
function toggleClass(element, className) {
  if (element.classList) element.classList.toggle(className);
  else if (hasClass(element, className)) removeClass(element, className);
  else addClass(element, className);
}

// node_modules/dom-helpers/esm/width.js
function getWidth(node, client) {
  var win = isWindow(node);
  return win ? win.innerWidth : client ? node.clientWidth : offset(node).width;
}

// node_modules/dom-helpers/esm/index.js
var esm_default = {
  addEventListener: addEventListener_default,
  removeEventListener: removeEventListener_default,
  triggerEvent,
  animate: animate_default,
  filter: filterEvents,
  listen: listen_default,
  style: css_default,
  getComputedStyle,
  attribute,
  activeElement,
  ownerDocument,
  ownerWindow,
  requestAnimationFrame: request,
  cancelAnimationFrame: cancel,
  matches,
  height,
  width: getWidth,
  offset,
  offsetParent,
  position,
  contains,
  scrollbarSize,
  scrollLeft: scrollLeft_default,
  scrollParent,
  scrollTo,
  scrollTop: scrollTop_default,
  querySelectorAll: qsa,
  closest,
  addClass,
  removeClass,
  hasClass,
  toggleClass,
  transitionEnd,
  childNodes,
  childElements,
  nextUntil,
  parents,
  siblings,
  clear,
  insertAfter,
  isInput,
  isVisible,
  prepend,
  remove,
  text
};
export {
  activeElement,
  addClass,
  addEventListener_default as addEventListener,
  animate_default as animate,
  attribute,
  cancel as cancelAnimationFrame,
  childElements,
  childNodes,
  clear,
  closest,
  contains,
  esm_default as default,
  filterEvents as filter,
  getComputedStyle,
  hasClass,
  height,
  insertAfter,
  isInput,
  isVisible,
  listen_default as listen,
  matches,
  nextUntil,
  offset,
  offsetParent,
  ownerDocument,
  ownerWindow,
  parents,
  position,
  prepend,
  qsa as querySelectorAll,
  remove,
  removeClass,
  removeEventListener_default as removeEventListener,
  request as requestAnimationFrame,
  scrollLeft_default as scrollLeft,
  scrollParent,
  scrollTo,
  scrollTop_default as scrollTop,
  scrollbarSize,
  siblings,
  css_default as style,
  text,
  toggleClass,
  transitionEnd,
  triggerEvent,
  getWidth as width
};
//# sourceMappingURL=dom-helpers.js.map
